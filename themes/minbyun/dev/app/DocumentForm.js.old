import React, {Component, PropTypes} from 'react';
import update from 'react-addons-update';  // for update()
import 'babel-polyfill'; // for update(), find() ...
import axios from 'axios';

import SearchBar from './SearchBar';
import Textarea from './Textarea';
import DateForm from './DateForm';

class DocumentForm extends Component {
	componentWillMount(){
		this.setState(this.props.document);
	}
	updateFields(fields){ if(!fields) return;
		this.setState(update(this.state, {
			custom: { $merge: fields}
		}));
	}
	defaultTaxonomyTerm(cid){
		let minIdx = -1;
		let firstTermId;
		this.props.documentFormData.taxonomy[cid].forEach((term) => {
			if(minIdx < 0){
				minIdx = term.idx; firstTermId = term.tid;
			} else if(minIdx > 0 && term.idx < minIdx){
				minIdx = term.idx; firstTermId = term.tid;
			}
		});
		return firstTermId;
	}
	updateSingleField(field, index, value){
		if(field.fid > 0){
			if(index === undefined){
				this.setState(update(this.state, { custom: {
					['f'+field.fid]: {$set: value}
				}}));
			} else {
				this.setState(update(this.state, { custom: {
					['f'+field.fid]: {
						[index]: {$set: value}
					}
				}}));
			}
		} else {
			this.setState(update(this.state, {
				[field.fid]: {$set: value}
			}));
		}
	}
	handleChange(field, index, event){
		let value = (field.form != 'file' ? event.target.value : event.target.files[0]);
		this.updateSingleField(field, index, value);
	}
	handleSubmit(event){
		event.preventDefault();

		let formData = new FormData();
		this.props.documentFormData.fields.forEach((f) => {
			if(f.form == 'file'){
				if(f.multiple == '1'){
					this.state.custom['f'+f.fid].forEach((file) => {
						if(file.name){
							formData.append('f'+f.fid+'[]', file);
						}
					});
				} else {
					let file = this.state.custom['f'+f.fid];
					if(file.name){
						formData.append('f'+f.fid, file);
					}
				}
			}
		});
		formData.append('document', JSON.stringify(this.state));

		axios.post(this.props.apiUrl+'/document/new', formData)
		.then((response) => {
			console.log(response.data);
		});
	}
	handleClickToAddInputForm(field){
		let value = '';
		switch(field.type){
			case 'taxonomy':
				value = this.defaultTaxonomyTerm(field.cid); break;
			case 'date':
				value = {year: '', month: ''}; break;
			case 'image': case 'file':
				value = {filename: ''}; break;
			default:
				value = '';
		}
		this.setState(update(this.state, {
			custom: {['f'+field.fid]: {$push: [value]}}
		}));
	}
	message(field){
		switch(field.form){
			case 'file':
				let accept = (field.type == 'file' ? 'pdf, hwp, doc, docx' : 'jpg, png');
				return `* 파일형식: ${accept}`;
		}
	}
	inputForm(field, value, index){
		switch(field.form){
			case 'text':
				return <input type="text" value={value} onChange={this.handleChange.bind(this, field, index)} />;
			case 'search':
				let searchInfo = this.props.documentFormOptions.search_in_docform.find((s) => s.field == field.fid);
				return (
					<SearchBar value={value} field={field} index={index}
						searchApiUrl={this.props.apiUrl+'/'+searchInfo.api}
						resultMap = {searchInfo.resultmap}
						updateFields={this.updateFields.bind(this)}
						handleChange={this.handleChange.bind(this)}
					/>
				);
			case 'file':
				let accept = (field.type == 'file' ? '.pdf, .hwp, .doc, .docx' : '.jpg, .png');
				return (
					<div>
						<input type="text" value={value.name || value.filename} />
						<label className="button">
							<span>찾기</span>
							<input style={{display: 'none'}} type="file" accept={accept} onChange={this.handleChange.bind(this, field, index)} />
						</label>
					</div>
				);
			case 'select':
				let options = [];
				this.props.documentFormData.taxonomy[field.cid].forEach((term) => {
					options[term.idx] = <option key={term.tid} value={term.tid}>{term.name}</option>;
				});
				return (
					<select value={value} onChange={this.handleChange.bind(this, field, index)}>
						{options}
					</select>
				);
			case 'radio':
				let radioButtons = [];
				this.props.documentFormData.taxonomy[field.cid].forEach((term) => {
					let checked = (value == term.tid ? true : false);
					radioButtons[term.idx] = (
						<label key={term.tid}>
							<input type="radio" name={'taxonomy_'+term.cid} value={term.tid} defaultChecked={checked} onChange={this.handleChange.bind(this, field, index)} />
							{term.name}
						</label>
					);
				});
				return radioButtons;
			case 'Ym':
				return <DateForm field={field} value={value} index={index} updateSingleField={this.updateSingleField.bind(this)} />
			case 'fieldset':
				let subFormFields = [];
				this.props.documentFormData.fields.forEach((f) => {
					if(f.parent == field.fid){
						subFormFields[f.idx] = this.documentField(f);
					}
				});
				return <div className="table">{subFormFields}</div>;
		}
		switch(field.type){
			case 'textarea':
				return <Textarea field={field} value={value} index={index} handleChange={this.handleChange.bind(this)} />
		}

	}
	documentField(field){
		let actionShow = this.props.documentFormOptions.action_show.find((item) => item.field == field.fid);
		if(actionShow){
			let isHidden = true;
			this.props.documentFormData.fields.forEach((f) => {
				if(f.type == 'taxonomy' && this.state.custom['f'+f.fid] == actionShow.term){
					isHidden = false; return false;
				}
			});
			if(isHidden) return null;
		}

		let inputForms;
		let value = (field.fid > 0 ? this.state.custom['f'+field.fid] : this.state[field.fid]);
		if(field.multiple == '1'){
			inputForms = value.map((v, i) => (
				<div key={i} className="table__row">
					<div className="table__col">
						{this.inputForm(field, v, i)}
					</div>
					<div className="table__col">
						<span className="button" onClick={this.handleClickToAddInputForm.bind(this, field)}>추가</span>
					</div>
				</div>
			));
			inputForms = (
				<div className="table">
					{inputForms}
					<div className="table__row">{this.message(field)}</div>
				</div>
			);
		} else {
			inputForms = (
				<div className="table">
					{this.inputForm(field, value)}
					<div className="table__row">{this.message(field)}</div>
				</div>
			);
		}
		return (
			<div key={field.fid} className="table__row">
				<div className="table__col">{field.subject}</div>
				<div className="table__col">
					{inputForms}
				</div>
			</div>
		);
	}
	render(){
		let requiredFields = [];
		let electiveFields = [];
		/*
		for(let f in this.props.defaultFields){
			if(this.props.defaultFields[f].required == '1'){
				requiredFields
			} else {

			}
			documentFields[this.props.defaultFields[f].idx] = this.documentField(this.props.defaultFields[f]);
		}
		*/
		this.props.documentFormData.fields.forEach((field) => {
			if(field.parent == 0){
				documentFields[field.idx] = this.documentField(field);
			}
		});

		return (
			<div className="document-form">
				<h1>자료 입력하기</h1>
				<form onSubmit={this.handleSubmit.bind(this)}>
					<div className="table document-form__required">
						<div className="table__row">
							<div className="table__col"></div>
							<div className="table__col">필수입력사항</div>
						</div>
						{documentFields}
					</div>
					<div className="document-form__elective">
					</div>
					<button type="submit">{this.props.submitLabel}</button>
				</form>
			</div>
		);
	}
}
DocumentForm.propTypes = {
	submitLabel: PropTypes.string.isRequired,
	documentFormData: PropTypes.object.isRequired,
	document: PropTypes.object.isRequired,
	documentFormOptions: PropTypes.object.isRequired,
	defaultFields: PropTypes.object.isRequired,
	apiUrl: PropTypes.string.isRequired,
	openedDocuments: PropTypes.array
};

export default DocumentForm;
